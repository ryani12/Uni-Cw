# -*- coding: utf-8 -*-
"""
Created on Thu Sep 7 15:15:17 2023

The program converts the Excel file described below into the following format:

| a_class | a_effective_date | a_channel | mea_value  | a_bud_fc1_fc2 | ingesttimestamp | a_actuals_orders |
|---------|------------------|-----------|------------|----------------|-----------------|------------------|
|   str   |    datetime      |    str    |    float   |      str       |       str       |        str       |

d_al_businesstargets


Describing the Excel file that we have:
    
- 1. All the data will be on two sheets.
- 2. The sheets contains the sections and data types contained below. Section names are written into the column Class.
- 3. The file may contain any number of blank columns on the left and any number of blank rows above
- 4. The sections wil be separated by at least one blank row.
- 5. All the sections have the same number of blank columns on the left.
- 6. The class sections mentioned below may appear in any order in the Excel sheet
- 7. The channels defined below may exist in each section.
- 8. The sections may contain rows with other values in the channel column. These rows will not be written to -
-    the output but will be reported as an information item.
- 10. Each section consists of contiguous rows and columns.
- 11. Each section will have 12 columns.
- 12. Sheet may contain section names not in the class list below and will be ignored.

@author: Q619346
"""



import pandas as pd
import numpy as np
from datetime import datetime


# define class and number type
 
classDef = [
    'Units', 
    'BMW', 
    'MINI', 
    'MM', 
    'LCV', 
    'Margin %', 
    'RMT %'
]


channelDef = [
    'Business Channel',
    'Corporate Sales',
    'Major Corporate Sales',
    'International Sales',
    'International Account Management',
    'International Partnerships',
    'BPP',
    'Intermediaries',
    'Intermediaries International',
    'Agency',
    'Wholesale',
    'AlphaDrive',
    'Alphabet Partner',
    'Rental Services',
    'Group Car Schemes',
    'Corporate Account Management',
    'Corporate Partnerships',
    'Major Corporate Account Management',
    'Major Corporate Partnerships',
    'SME Direct',
    'Public Sector',
    'HUNTING TOTAL',
    'FARMING TOTAL',
    'CORP & INT  TOTAL',
    'OTHER DIRECT',
    'DIRECT TOTAL',
    'INDIRECT TOTAL',
    'SPECIAL TOTAL',
    'Total',
    'Excl GCS'

]


# classDef = [
#     'Units', 
#     'BMW', 
#     'MINI', 
#     'MM', 
#     'LCV'
# ]



# 1.) Import 


# import only the first sheet of the excel file, include two reads, one for path and the other for the file name
file_path = "C:\\src\\alphbet-mi\\Documents"
fc1_file_name = "FCI-23 data for Dashboard inc Corp Workings Evolve channels v1.xlsx"
bud_file_name = "BU3-23 data for Dashboard Evolve Channels Summary.xlsx"


# read xlsx to df
fc1_nb = pd.read_excel(file_path + '\\' + fc1_file_name, sheet_name=0, skiprows=0)
fc1_orders = pd.read_excel(file_path + '\\' + fc1_file_name, sheet_name=1, skiprows=0)

bud_nb = pd.read_excel(file_path + '\\' + bud_file_name, sheet_name=0, skiprows=0)
bud_orders = pd.read_excel(file_path + '\\' + bud_file_name, sheet_name=1, skiprows=0)



def cleanse_and_transform(df):
    
    
    # 2.) Cleanse & Filter - remove blank and redundant rows and columns
    
    
    # Rule 3 - Remove the empty columns on the left and remove the empty rows above
    
    while pd.isnull(df.iloc[:,0]).all():
        df=df.drop(df.columns[0],axis=1)
    
    while pd.isnull(df.iloc[0,:]).all(): 
        df=df.drop(df.index[0],axis=0)
    
    
    # Rule 4 - Remove the blank rows which seperate the sections
    
    for index, row in df.iterrows():
        if pd.isnull(row[0]):
            df.drop(index, inplace=True)
    
    
    # Rule 11 - Keeping the df to 12 columns for each section
    
    if len(df.columns) > 13:
        for col in df.columns[13:]:
            df.drop(col, axis=1, inplace=True)
    
    
 
    
    # Rule 8 - remove calculated data and data which isn't required
    
    type_values = ['FCI', 'FCII', 'BUD']
    
    # # dont drop totals for RMT% and Margin %    
    # keep =  classDef + channelDef
    # mask = df.iloc[:, 0].isin(keep) & ~(df.iloc[:, 0].isin(classDef) & df.iloc[:, 0].isin(channelDef))
    # cont = df.applymap(lambda x: x in type_values).any(axis=1)  #iterates through the rows to check if type_values exists

    # mask = mask | cont
    # df = df.drop(index = df[~mask].index)
    
    
    mask = df.iloc[:, 0] == 'Grand Total'
    df.iloc[:, 0]  = df.iloc[:, 0].replace('Grand Total', 'Total')
    
    # count number of classDef
    num_classDef = len(classDef)
    
    # count number of occurrences of each value in channelDef
    channel_counts = df.iloc[:, 0].value_counts()
    
    # itterate each value in channelDef 
    # and check if value occurs more than classDef num of times and drop
    for value in channelDef:
       if channel_counts[value] > num_classDef:
           index_to_drop = df[df.iloc[:, 0] == value].index[-1]
           df = df.drop(index_to_drop)
    
    
    # replace 'MTD' and 'YTD' with NaN
    df = df.replace(['MTD', 'YTD'], np.nan)
    
    
    # replace NaN with 0
    for index, row in df.iterrows():
       if row[0] in channelDef:
           nan_indices = row.index[row.isna()]
           if len(nan_indices) > 0:
               row[nan_indices] = 0
    
    
    
    # 3.) Transform
    
    
    # reset index
    df.reset_index(drop = True, inplace = True)
    
    
    # temporary total_row removal and store
    total_row = df[df.isin(type_values).any(axis=1)]
    tr_index = total_row.index
    df = df.drop(index=tr_index)
    
    
    # store type column and map
    types = total_row.iloc[:, 2:].values[0]
    mapped_types = [t if t in type_values else None for t in types]
    
    
    # initialize list for reshaped df
    reshaped_dfs = []
    
    # iterate through df to identify class rows and reshape df
    for index, row in df.iterrows():
        row_value = row[0]
        if row_value in classDef:
            class_name = row_value
        elif row_value == 'Business Channel':
            effective_dates = row[1:].dropna().values
        elif row_value in channelDef:
            channel_name = row_value
            values = row[1:].dropna().values
            min_length = min(len(effective_dates), len(values))
            section_reshaped_df = pd.DataFrame({
            'a_effective_date': effective_dates[:min_length],
            'a_channel': channel_name,
            'mea_value': values[:min_length],
            'a_class': class_name
            })
            reshaped_dfs.append(section_reshaped_df)
    
    

    
    # concatenate reshaped df
    final_reshaped_df = pd.concat(reshaped_dfs, ignore_index=True)
    
    # final_reshaped_df.loc[mask, df.columns[0]] = 'Grand Total'
    
    # convert Eeffective_date to datetime
    final_reshaped_df['a_effective_date'] = pd.to_datetime(final_reshaped_df['a_effective_date'], format = '%Y-%m-%d')
    
    # convert value to float
    final_reshaped_df['mea_value'] = final_reshaped_df['mea_value'].astype(float)
    
    # add type column
    final_reshaped_df['a_bud_fc1_fc2'] = mapped_types[0]
    
    #add ingesttimestamp column
    final_reshaped_df['ingesttimestamp'] = datetime.now().strftime("%Y-%m-%d")
    
    return final_reshaped_df


# 4.) Validate & Export


fc1_nb_cleaned = cleanse_and_transform(fc1_nb)
fc1_orders_cleaned = cleanse_and_transform(fc1_orders)
bud_nb_cleaned = cleanse_and_transform(bud_nb)
bud_orders_cleaned = cleanse_and_transform(bud_orders)

fc1_nb_cleaned = fc1_nb_cleaned.assign(a_actuals_orders='New Business')
fc1_orders_cleaned = fc1_orders_cleaned.assign(a_actuals_orders='Orders')
bud_nb_cleaned = bud_nb_cleaned.assign(a_actuals_orders='New Business')
bud_orders_cleaned = bud_orders_cleaned.assign(a_actuals_orders='Orders')

# concatenate df1 and df2
final_df = pd.concat([fc1_nb_cleaned, fc1_orders_cleaned, bud_nb_cleaned, bud_orders_cleaned], ignore_index=True)

# check dtype
print(final_df.dtypes)

# count values within each section (should be 960)
for c in classDef:
    count = final_df[final_df['a_class'] == c]['a_class'].count()
    print(c, count)

# df to csv
final_df.to_csv('C:\\src\\alphbet-mi\\Documents\\test Transformed FCI and BUD Data.csv', index=False)
